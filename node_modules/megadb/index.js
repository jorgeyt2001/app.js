const fs = require('graceful-fs'),
      path = require('path'),
      mkdirp = require('mkdirp');



let global_object = new Object() //objeto interno, no eliminar!


/*

//*--------------megadb---------------*\\
||                                     ||
||   CONTACTO_DISCORD: MegaStar#0782   ||
||                                     ||
||   https://www.npmjs.com/~megastar   ||
\\-------------------------------------//

*/

module.exports = {
  crearDB
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


/*

Funciones internas:
  - readJSON
  - saveJSON
  - check_path_object
  - ErrorDesc
  - get_data
  - is_float
  - is_num

*/


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function is_float(n) {
  return typeof(n, "Number") && !!(n % 1)
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function is_num(n) {
  return !!parseInt(n) == false && parseInt(n) != 0 ? false : true
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function readJSON(path_file_name) {
  if(!fs.existsSync(path_file_name)) throw new Error(`[ERROR] El archivo ${path_file_name} no existe.`)
  var obj_data;
  try{
    let get_data = fs.readFileSync(path_file_name, 'utf8')
    obj_data = JSON.parse(get_data)
  }
  catch(error) {
    throw new Error(`[ERROR] Ocurrio un problema al tratar de leer los datos del archivo ${path_file_name}, error: ${error}`)
  }
  return obj_data
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function saveJSON(path_file_name, new_object) {
  if(!fs.existsSync(path_file_name)) throw new Error(`[ERROR] El archivo ${path_file_name} no existe.`)
  try{
    fs.writeFileSync(path_file_name, JSON.stringify(new_object, null, 2), 'utf8')
    return true
  }
  catch(error) {
    throw new Error(`[ERROR] Ocurrio un error al tratar de guardar los datos en el archivo ${path_file_name}, error: ${error}`)
  }
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function check_path_object(path_object, split_object) {
  if(!path_object) throw new Error(`[ERROR] El nombre de la clave no fue especificado`)
  if(typeof path_object != "string") throw new Error(`[ERROR] El nombre de la clave debe ser un string`)
  if(path_object.includes(`${split_object}${split_object}`)) throw new Error(`[ERROR] El nombre de la clave no debe de contener el signo ${split_object} seguido de otro.`)
  if(path_object.startsWith(split_object) || path_object.endsWith(split_object)) throw new Error(`[ERROR] El nombre de la clave no debe empezar ni terminar con un ${split_object}`)
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function ErrorDesc(type_error, description) {
  error_object = {
    type: type_error,
    mensaje: description
  }
  return error_object
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function get_path(sub_directory) {
  let directorio = path.dirname(require.main.filename).split("/");
  for(var x = 0; x < directorio.length; x++) {
    if(fs.existsSync(`${directorio.join("/")}/node_modules`)) {
      if(!fs.existsSync(`${directorio.join("/")}/mega_databases`)) {
        mkdirp(`${directorio.join("/")}/mega_databases`, function(err) {
          if(err) throw new Error(`[ERROR] No se pudo crear la carpeta mega_databases donde se almacenaran las base de datos, error: ${err}`)
          console.log(`[CREANDO DIRECTORIO] Acaba de crearse la carpeta mega_databases, en esta carpeta ${sub_directory != false ? "se creara tu sub directorio" : "se almacenaran tus base de datos"}.`)
        })
      }

      if(sub_directory) {
        if(!fs.existsSync(`${directorio.join("/")}/mega_databases/${sub_directory}`)) {
          mkdirp(`${directorio.join("/")}/mega_databases/${sub_directory}`, function(err) {
          if(err) throw new Error(`[ERROR] No se pudo crear el sub directorio ${sub_directory}, error: ${err}`)
          console.log(`[CREANDO SUB DIRECTORIO] Acaba de crearse el sub directorio ${sub_directory}, en esta carpeta se almacenaran tus base de datos.`)
          })
        }
      }
      path_main_file = sub_directory != false ? `${directorio.join("/")}/mega_databases/${sub_directory}` : `${directorio.join("/")}/mega_databases`
      return path_main_file
    }
    directorio = directorio.slice(0, -1)
  }
  return false
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function crearDB(database_name, sub_directory = false) { //constuctor
  if(!database_name) throw new Error(`[ERROR] Necesitas colocar el nombre de la base de datos`)
  if(typeof database_name != "string") throw new Error(`[ERROR] El nombre de la base de datos ${database_name} debe ser un string`)
  if(database_name.includes("/")) throw new Error(`[ERROR] El nombre de la base de datos ${database_name} no debes contener el simbolo de barra ascendente: /`)
  database_name = database_name.trim()
  if(database_name.length <= 0) throw new Error(`[ERROR] Necesitas colocar un nombre a la base de datos`)

  if(sub_directory) {
    if(typeof sub_directory != "string") throw new Error(`[ERROR] El nombre del sub directorio ${database_name} debe ser un string`)
    if(sub_directory.includes("/")) throw new Error(`[ERROR] El nombre del sub directorio ${sub_directory} no debe contener el simbolo de barra ascendente: /`)
    sub_directory = sub_directory.trim()
    if(sub_directory.length <= 0) throw new Error(`[ERROR] Necesitas colocar un nombre al sub directorio`)
  }
  this.database_name = database_name
  this.object_id = sub_directory ? `${sub_directory}/${database_name}` : database_name
  this.path_main_carpet = get_path(sub_directory)
  //En caso de que no encuentre la ruta correcta
  if(this.path_main_carpet == false) throw new Error(`[ERROR] Ocurrio un problema obteniendo la ruta de la base de datos, asegurate que tu proyecto tenga la carpeta node_modules`)
  this.path_file_name = `${this.path_main_carpet}/${database_name}.json`
  if(!fs.existsSync(this.path_file_name)) {
    fs.writeFileSync(this.path_file_name, JSON.stringify({}, null, 2), { flag: 'wx' }, function(err) {
      if(err) throw new Error(`[ERROR] No se pudo crear la base de datos ${database_name}, error: ${err}`)
    });
  }
  this.preprare_db = function(path_file_name, object_id) {
    if(!global_object[object_id]) {
      global_object[object_id] = readJSON(path_file_name)
      return
    }
    return
  }(this.path_file_name, this.object_id)
}



//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\



/*

constructor:
  - crearDB

Metodos:
  - existeDB
  - establecer
  - obtener
  - tiene
  - eliminar
  - purgeall
  - sumar
  - restar
  - push
  - extract
  - datos
  - ordenar
  - random
  - convert_megadtbs
  - keys
  - values
  - size
  - find
  - map
  - filter

*/


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function existeDB(database_name) { //retorna true o false
  if(!database_name) throw new Error(`[ERROR] El nombre de la base de datos no fue especificado`)
  if(typeof database_name != "string") throw new Error(`[ERROR] El nombre de la base de datos debe ser un string`)
  if(!fs.existsSync(`${this.path_main_carpet}/${database_name}.json`)) return false
  return true
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function establecer(clave, valor, split_object) { //retorna promesa
  if(!split_object) split_object = "."
  if(typeof split_object != "string") throw new Error(`[ERROR] El signo que se usara para la clave debe ser un string`)

  check_path_object(clave, split_object)
  if(!valor && valor != 0) throw new Error(`[ERROR] El valor no fue especificado`)
  var split_object = clave.split(split_object)
  var object_data = global_object[this.object_id]

  for(var x in split_object) {
    var key = split_object[x]
    if(x == split_object.length-1) {
      object_data[key] = valor
      break
    }
    if(typeof object_data[key] == "undefined") {
      object_data = object_data[key] = {}
      continue
    }
    //con esto evitamos el bug del type {} == []
    object_data = (Array.isArray(object_data[key]) || typeof object_data[key] != "object") ? object_data[key] = {} : object_data[key]
  }
  let save_data = saveJSON(this.path_file_name, global_object[this.object_id])
  if(save_data) {
    return Promise.resolve(global_object[this.object_id])
  }
  return Promise.reject(ErrorDesc("DATABASE NO EXISTENTE", `[establecer] La base de datos ${this.database_name} no existe: ${this.path_main_file}`)) //tal vez ocurre algun error ?)
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function tiene(clave, split_object) { //retorna true o false
  if(!split_object) split_object = "."
  if(typeof split_object != "string") throw new Error(`[ERROR] El signo que se usara para la clave debe ser un string`)

  check_path_object(clave, split_object)
  var split_object = clave.split(split_object)
  var object_data = global_object[this.object_id]
  for(var x in split_object) {
    var key = split_object[x]
    if(typeof object_data[key] != "undefined") {
      if(x == split_object.length-1) {
        return true
      }
      object_data = object_data[key]
      continue
    }
    return false
  }
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function obtener(clave, split_object) { //retorna promesa
  if(!split_object) split_object = "."
  if(typeof split_object != "string") throw new Error(`[ERROR] El signo que se usara para la clave debe ser un string`)
  check_path_object(clave, split_object)
  var split_object = clave.split(split_object)
  var object_data = global_object[this.object_id]
  for(var x in split_object) {
    var key = split_object[x]
    if(typeof object_data[key] != "undefined") {
      if(x == split_object.length-1) {
        return Promise.resolve(object_data[key])
      }
      object_data = object_data[key]
      continue
    }
    return Promise.reject(ErrorDesc("PROPIEDAD NO EXISTENTE", `[obtener] No se encontro la propiedad ${key}, base de datos: ${this.database_name}`))
  }
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function eliminar(clave, split_object) { //retorna true o false
  if(!split_object) split_object = "."
  if(typeof split_object != "string") throw new Error(`[ERROR] El signo que se usara para la clave debe ser un string`)

  check_path_object(clave, split_object)
  var split_object = clave.split(split_object)
  var object_data = global_object[this.object_id]

  for(var x in split_object) {
    var key = split_object[x]
    if(typeof object_data[key] != "undefined") {
      if(x == split_object.length-1) {
        delete object_data[key]
        let save_data = saveJSON(this.path_file_name, global_object[this.object_id])
        if(save_data) {
          return true
        }
        return false //tal vez ocurre algun error ?)
      }
      object_data = object_data[key]
      continue
    }
    return false
  }
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function purgeall() { //retorna true o false
  var object_data = global_object[this.object_id]
  global_object[this.object_id] = {}
  let save_data = saveJSON(this.path_file_name, global_object[this.object_id])
  if(save_data) {
    return true
  }
  return false
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function sumar(clave, number, split_object) { //retorna promesa
  if(!split_object) split_object = "."
  if(typeof split_object != "string") throw new Error(`[ERROR] El signo que se usara para la clave debe ser un string`)

  check_path_object(clave, split_object)

  if(!number && number != 0) throw new Error(`[ERROR] Necesitas colocar el valor(numero)`)
  if(!is_num(number)) throw new Error(`[ERROR] El valor debe ser un numero`)
  number = is_float(number) ? parseFloat(number) : parseInt(number)

  var split_object = clave.split(split_object)
  var object_data = global_object[this.object_id]
  for(var x in split_object) {
    var key = split_object[x]
    if(typeof object_data[key] != "undefined") {
      if(x == split_object.length-1) {
        if(!is_num(object_data[key])) return Promise.reject(ErrorDesc("NUMERO NO EXISTENTE", `[sumar] El valor de la propiedad ${key} no es un numero, base de datos: ${this.database_name}`))
        object_data[key] = (is_float(object_data[key]) ? parseFloat(object_data[key]) : parseInt(object_data[key])) + number
        let save_data = saveJSON(this.path_file_name, global_object[this.object_id])
        if(save_data) {
          return Promise.resolve(object_data[key])
        }
        return Promise.reject(ErrorDesc("DATABASE NO EXISTENTE", `[sumar] La base de datos ${this.database_name} no existe: ${this.path_main_file}`)) //tal vez ocurre algun error ?)
      }
      object_data = object_data[key]
      continue
    }
    return Promise.reject(ErrorDesc("PROPIEDAD NO EXISTENTE", `[sumar] No se encontro la propiedad ${key}, base de datos: ${this.database_name}`))
  }
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function restar(clave, number, split_object) { //retorna promesa
  if(!split_object) split_object = "."
  if(typeof split_object != "string") throw new Error(`[ERROR] El signo que se usara para la clave debe ser un string`)

  check_path_object(clave, split_object)
  if(!number && number != 0) throw new Error(`[ERROR] Necesitas colocar el valor(numero)`)

  if(!is_num(number)) throw new Error(`[ERROR] El valor debe ser un numero`)
  number = is_float(number) ? parseFloat(number) : parseInt(number)

  var split_object = clave.split(split_object)
  var object_data = global_object[this.object_id]

  for(var x in split_object) {
    var key = split_object[x]
    if(typeof object_data[key] != "undefined") {
      if(x == split_object.length-1) {
        if(!is_num(object_data[key])) return Promise.reject(ErrorDesc("NUMERO NO EXISTENTE", `[restar] El valor de la propiedad ${key} no es un numero, base de datos: ${this.database_name}`))
        object_data[key] = (is_float(object_data[key]) ? parseFloat(object_data[key]) : parseInt(object_data[key])) - number
        let save_data = saveJSON(this.path_file_name, global_object[this.object_id])
        if(save_data) {
          return Promise.resolve(object_data[key])
        }
        return Promise.reject(ErrorDesc("DATABASE NO EXISTENTE", `[restar] La base de datos ${this.database_name} no existe: ${this.path_main_file}`)) //tal vez ocurre algun error ?)
      }
      object_data = object_data[key]
      continue
    }
    return Promise.reject(ErrorDesc("PROPIEDAD NO EXISTENTE", `[restar] No se encontro la propiedad ${key}, base de datos: ${this.database_name}`))
  }
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function push(clave, valor, split_object) { //retorna promesa
  if(!split_object) split_object = "."
  if(typeof split_object != "string") throw new Error(`[ERROR] El signo que se usara para la clave debe ser un string.`)

  check_path_object(clave, split_object)
  if(!valor && valor != 0) throw new Error(`[ERROR] El valor no fue especificado`)

  var split_object = clave.split(split_object)
  var object_data = global_object[this.object_id]

  for(var x in split_object) {
    var key = split_object[x]
    if(typeof object_data[key] != "undefined") {
      if(x == split_object.length-1) {
        if(!Array.isArray(object_data[key])) return Promise.reject(ErrorDesc("ARRAY NO EXISTENTE", `[push] El valor de la propiedad ${key} no es un array, base de datos: ${this.database_name}`))
        object_data[key].unshift(valor)
        let save_data = saveJSON(this.path_file_name, global_object[this.object_id])
        if(save_data) {
          return Promise.resolve(object_data[key])
        }
        return Promise.reject(ErrorDesc("DATABASE NO EXISTENTE", `[push] La base de datos ${this.database_name} no existe: ${this.path_main_file}`)) //tal vez ocurre algun error ?)
      }
      object_data = object_data[key]
      continue
    }
    return Promise.reject(ErrorDesc("PROPIEDAD NO EXISTENTE", `[push] No se encontro la propiedad ${key}, base de datos: ${this.database_name}`))
  }
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function extract(clave, valor, split_object) { //retorna promesa
  if(!split_object) split_object = "."
  if(typeof split_object != "string") throw new Error(`[ERROR] El signo que se usara para la clave debe ser un string.`)

  check_path_object(clave, split_object)
  if(!valor && valor != 0) throw new Error(`[ERROR] El valor no fue especificado`)

  var split_object = clave.split(split_object)
  var object_data = global_object[this.object_id]

  for(var x in split_object) {
    var key = split_object[x]
    if(typeof object_data[key] != "undefined") {
      if(x == split_object.length-1) {
        if(!Array.isArray(object_data[key])) return Promise.reject(ErrorDesc("ARRAY NO EXISTENTE", `[extract] El valor de la propiedad ${key} no es un array, base de datos: ${this.database_name}`))
        if(!object_data[key].includes(valor)) return Promise.reject(ErrorDesc("ITEM NO EXISTENTE", `[extract] El item ${valor} no existe en el array ${key}, base de datos: ${this.database_name}`))
        object_data[key].splice(object_data[key].indexOf(valor), 1)
        let save_data = saveJSON(this.path_file_name, global_object[this.object_id])
        if(save_data) {
          return Promise.resolve(object_data[key])
        }
        return Promise.reject(ErrorDesc("DATABASE NO EXISTENTE", `[extract] La base de datos ${this.database_name} no existe: ${this.path_main_file}`)) //tal vez ocurre algun error ?)
      }
      object_data = object_data[key]
      continue
    }
    return Promise.reject(ErrorDesc("PROPIEDAD NO EXISTENTE", `[extract] No se encontro la propiedad ${key}, base de datos: ${this.database_name}`))
  }
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function datos() { //retorna promesa
  return Promise.resolve(global_object[this.object_id])
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function ordenar(clave, valor, split_object) { //tipos: (false, false) => (false, path_object) => (path_object, false) => (path_object, path_object) [retorna promesa con un array]
  if(!split_object) split_object = "."
  if(typeof split_object != "string") throw new Error(`[ERROR] El signo que se usara para la clave debe ser un string.`)

  if(!clave && clave != false) throw new Error("[ERROR] El nombre de la clave no fue especificado")
  if(clave != false && typeof clave != "string") throw new Error("[ERROR] Formato invalido, la clave debe de ser un string o false en caso de que la clave no sea un objecto con propiedades")
  if(!valor && valor != false && valor != 0) throw new Error("[ERROR] El valor no fue especificado")

  let final_array = []

  if(clave == false) {
    //si la clave es false
    if(valor == false) {
      //si la clave y valor son false
      if(Object.keys(global_object[this.object_id]).length <= 0) return Promise.reject(ErrorDesc("PROPIEDAD NO EXISTENTE", `[ordenar] Actualmente no hay ninguna propiedad, base de datos: ${this.database_name}`))
      for(var key in global_object[this.object_id]) {
        if(typeof global_object[this.object_id][key] != "number") return Promise.reject(ErrorDesc("NUMERO NO EXISTENTE", `[ordenar] El valor de la propiedad ${key} no es un numero, base de datos: ${this.database_name}`))
        final_array.push({clave: key, valor: global_object[this.object_id][key]})
      }
      final_array.sort(function (a,b) {
        return b.valor - a.valor
      })
      return Promise.resolve(final_array)
    }

    //si la clave es false y el valor es un string (path object)
    if(typeof valor != "string") throw new Error("[ERROR] Formato invalido, el valor debe ser un string o false en caso de que el valor no sea un objecto con propiedades")

    if(valor.includes(`${split_object}${split_object}`)) throw new Error(`[ERROR] El nombre del valor no debe de contener el signo ${split_object} seguido de otro`)
    if(valor.startsWith(split_object) || valor.endsWith(split_object)) throw new Error(`[ERROR] El nombre del valor no debe empezar ni terminar con un ${split_object}`)

    let properties = valor.split(split_object)

    for(var key1 in global_object[this.object_id]) {
      var object_data = global_object[this.object_id][key1]
      for(var x in properties) {
        var index = properties[x]
        if(typeof object_data[index] != "undefined") {
          if(x == properties.length-1) {
            if(typeof object_data[index] != "number") return Promise.reject(ErrorDesc("NUMERO NO EXISTENTE", `[ordenar] El valor de la propiedad ${index} no es un numero, base de datos: ${this.database_name}`))
            final_array.push({clave: key1, valor: object_data})
          }
          object_data = object_data[index]
          continue
        }
        return Promise.reject(ErrorDesc("PROPIEDAD NO EXISTENTE", `[ordenar] No se encontro la propiedad ${index}, base de datos: ${this.database_name}`))
      }
    }
    final_array.sort(function (a,b) {
      return b.valor[properties[properties.length - 1]] - a.valor[properties[properties.length - 1]]
    })
    return Promise.resolve(final_array)
  }


  if(valor == false) {

    //si la clave es un string (path object) y el valor es false
    check_path_object(clave, split_object)
    let properties = clave.split(split_object)

    var object_data = global_object[this.object_id]
    for(var x in properties) {
      var index = properties[x]
      if(typeof object_data[index] != "undefined") {
        if(x == properties.length-1) {
          for(var key in object_data[index]) {
            if(typeof object_data[index][key] != "undefined") {
              if(typeof object_data[index][key] != "number") return Promise.reject(ErrorDesc("NUMERO NO EXISTENTE", `[ordenar] El valor de la propiedad ${key} no es un numero, base de datos: ${this.database_name}`))
              final_array.push({clave: key, valor: object_data[index][key]})
            }
          }
        }
        object_data = object_data[index]
        continue
      }
      return Promise.reject(ErrorDesc("PROPIEDAD NO EXISTENTE", `[ordenar] No se encontro la propiedad ${index}, base de datos: ${this.database_name}`))
    }

    final_array.sort(function (a,b) {
      return b.valor - a.valor
    })
    return Promise.resolve(final_array)
  }

  //Si la clave y valor son string (path object)

  if(typeof valor != "string") throw new Error("[ERROR] Formato invalido, el valor debe ser un string o false en caso de que el valor no sea un objecto con propiedades")

  if(valor.includes(`${split_object}${split_object}`)) throw new Error(`[ERROR] El nombre del valor no debe de contener el signo ${split_object} seguido de otro`)
  if(valor.startsWith(split_object) || valor.endsWith(split_object)) throw new Error(`[ERROR] El nombre del valor no debe empezar ni terminar con un ${split_object}`)


  check_path_object(clave, split_object)
  check_path_object(valor, split_object)

  let properties = clave.split(split_object)
  let valuerties = valor.split(split_object)


  var object_data = global_object[this.object_id]

  for(var x = 0; x < properties.length; x++) {
    let index = properties[x]
    if(typeof object_data[index] != "undefined") {
      if(x == properties.length - 1) {
        object_data = object_data[index]
        for(var key in object_data) {
          let propobject = object_data[key]
          for(var y = 0; y < valuerties.length; y++) {
            let index_2 = valuerties[y]
            if(typeof propobject[index_2] != "undefined") {
              if(y == valuerties.length - 1) {
                if(typeof propobject[index_2] != "undefined") {
                  if(typeof propobject[index_2] != "number") return Promise.reject(ErrorDesc("NUMERO NO EXISTENTE", `[ordenar] El valor de la propiedad ${index_2} no es un numero, base de datos: ${this.database_name}`))
                  final_array.push({clave: key, valor: propobject})
                }
              }
              propobject = propobject[index_2]
              continue
            }
            return Promise.reject(ErrorDesc("PROPIEDAD NO EXISTENTE", `[ordenar] No se encontro la propiedad ${index_2}, base de datos: ${this.database_name}`))
          }
        }
      }
      object_data = object_data[index]
      continue
    }
    return Promise.reject(ErrorDesc("PROPIEDAD NO EXISTENTE", `[ordenar] No se encontro la propiedad ${index}, base de datos: ${this.database_name}`))
  }

  final_array.sort(function (a,b) {
    return b.valor[valuerties[valuerties.length - 1]] - a.valor[valuerties[valuerties.length - 1]]
  })
  return Promise.resolve(final_array)
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function random(clave, cantidad, split_object) { //retorna promesa con un array
  if(clave !== false && typeof clave != "string") throw new Error(`[ERROR] La clave debe ser un string o false`)
  let array = []
  if(!cantidad && cantidad != 0) throw new Error(`[ERROR] Necesitas colocar el valor(numero)`)
  if(typeof cantidad != "number") throw new Error(`[ERROR] El valor debe ser un numero`)
  cantidad = cantidad > 0 ?  parseInt(cantidad) : 0

  if(!split_object) split_object = "."
  if(typeof split_object != "string") throw new Error(`[ERROR] El signo que se usara para la clave debe ser un string`)
  if(clave === false) {
    if(Object.keys(global_object[this.object_id]).length <= 0) return Promise.reject(ErrorDesc("PROPIEDAD NO EXISTENTE", `[random] Actualmente no hay ninguna propiedad, base de datos: ${this.database_name}`))
    let keys = Object.keys(global_object[this.object_id])
    for (var i = 0; i < cantidad; i++) {
      if(i >= keys.length) break
      var random_number = parseInt((Math.random() * keys.length));
      do {
        var existente = array.indexOf(keys[random_number]);
        if(existente >= 0) {
          random_number = parseInt((Math.random() * keys.length));
        }
        else {
          array.push(keys[random_number]);
          existente = -2;
        }
      }
      while(existente > -1);
    }
    let random_array = []
    if(array.length <= 0) return Promise.resolve(random_array)
    array.map(r => random_array.push({clave: r, valor: global_object[this.object_id][r]}))
    return Promise.resolve(random_array)
  }

  var split_object = clave.split(split_object)
  var object_data = global_object[this.object_id]

  for(var x in split_object) {
    var key = split_object[x]
    if(typeof object_data[key] != "undefined") {
      if(x == split_object.length-1) {
        if(typeof object_data[key] != "object" || typeof object_data[key] == "object" && Array.isArray(object_data[key])) return Promise.reject(ErrorDesc("OBJETO NO EXISTENTE", `[random] El valor de la propiedad ${key} no es un objeto, base de datos: ${this.database_name}`))

        let keys = Object.keys(object_data[key])
        for (var i = 0; i < cantidad; i++) {
          if(i >= keys.length) break
          var random_number = parseInt((Math.random() * keys.length));
          do {
            var existente = array.indexOf(keys[random_number]);
            if(existente >= 0) {
              random_number = parseInt((Math.random() * keys.length));
          }
            else {
              array.push(keys[random_number]);
              existente = -2;
            }
          }
          while(existente > -1);
        }
        let random_array = []
        if(array.length <= 0) return Promise.resolve(random_array)
        array.map(r => random_array.push({clave: r, valor: object_data[key][r]}))
        return Promise.resolve(random_array)
      }
      object_data = object_data[key]
      continue
    }
    return Promise.reject(ErrorDesc("PROPIEDAD NO EXISTENTE", `[random] No se encontro la propiedad ${key}, base de datos: ${this.database_name}`))
  }
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function convert_megadtbs() { //no retorna nada, solo es un adaptador
  if(this.database_name != "mega_db") throw new Error(`[ERROR] El nombre de la base de datos del constructor crearDB debe ser "mega_db"`)
  if(!fs.existsSync(`${this.path_main_carpet}/mega_db.json`)) throw new Error(`[ERROR] No se encontro el archivo mega_db.json en ${this.path_main_carpet}`)
  let mega_dtbs = readJSON(this.path_file_name)
  let successful_databases = []
  let invalid_databases = []
  if(Object.keys(mega_dtbs).length <= 0) throw new Error(`[ERROR] El archivo ${this.database_name} no contiene ninguna base de datos`)
  for(var key in mega_dtbs) {
    if(!mega_dtbs[key].hasOwnProperty("value")) throw new Error(`[ERROR] El archivo ${this.database_name} no contiene la estructura de la base de datos mega-dtbs`)
    if(!fs.existsSync(`${this.path_main_carpet}/${key}.json`)) {
      fs.writeFileSync(`${this.path_main_carpet}/${key}.json`, JSON.stringify(mega_dtbs[key].value, null, 2), { flag: 'wx' }, function(err) {
        if(err) throw new Error(`[ERROR] No se pudo crear la base de datos ${database_name}, error: ${err}`)
      });

      successful_databases.push(`${key}.json`)
      continue
    }
    invalid_databases.push(`${key}`)
  }
  console.log(`[ADAPTACION FINALIZADA]`)
  console.log(`[DATABASES ADAPTADAS CORRECTAMENTE] ${successful_databases.length > 0 ? successful_databases.join(" | ") : "Ninguno"}`)
  console.log(`[DATABASES ERRONEAS] ${invalid_databases.length > 0 ? invalid_databases.join(" | ") : "Ninguno"}`)
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function keys(clave = false, split_object) { //retorna promesa
  if(!split_object) split_object = "."
  if(typeof split_object != "string") throw new Error(`[ERROR] El signo que se usara para la clave debe ser un string`)
  if(clave === false) {
    let keys = Object.keys(global_object[this.object_id])
    return Promise.resolve(keys)
  }
  check_path_object(clave, split_object)
  var split_object = clave.split(split_object)
  var object_data = global_object[this.object_id]

  for(var x in split_object) {
    var key = split_object[x]
    if(typeof object_data[key] != "undefined") {
      if(x == split_object.length-1) {
        if(typeof object_data[key] != "object" || Array.isArray(object_data[key])) return Promise.reject(ErrorDesc("OBJETO NO EXISTENTE", `[keys] El valor de la propiedad ${key} no es un objeto, base de datos: ${this.database_name}`))
        let keys_obj = Object.keys(object_data[key])
        return Promise.resolve(keys_obj)
      }
      object_data = object_data[key]
      continue
    }
    return Promise.reject(ErrorDesc("PROPIEDAD NO EXISTENTE", `[keys] No se encontro la propiedad ${key}, base de datos: ${this.database_name}`))
  }
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function values(clave = false, split_object) { //retorna promesa
  if(!split_object) split_object = "."
  if(typeof split_object != "string") throw new Error(`[ERROR] El signo que se usara para la clave debe ser un string`)
  if(clave === false) {
    let values = Object.keys(global_object[this.object_id]).map(o => global_object[this.object_id][o])
    return Promise.resolve(values)
  }

  check_path_object(clave, split_object)
  var split_object = clave.split(split_object)
  var object_data = global_object[this.object_id]

  for(var x in split_object) {
    var key = split_object[x]
    if(typeof object_data[key] != "undefined") {
      if(x == split_object.length-1) {
        if(typeof object_data[key] != "object" || Array.isArray(object_data[key])) return Promise.reject(ErrorDesc("OBJETO NO EXISTENTE", `[values] El valor de la propiedad ${key} no es un objeto, base de datos: ${this.database_name}`))
        let values_obj = Object.keys(object_data[key]).map(o => object_data[key][o])
        return Promise.resolve(values_obj)
      }
      object_data = object_data[key]
      continue
    }
    return Promise.reject(ErrorDesc("PROPIEDAD NO EXISTENTE", `[values] No se encontro la propiedad ${key}, base de datos: ${this.database_name}`))
  }
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function size() { //retorna promesa
  return Object.keys(global_object[this.object_id]).length
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function find(clave, callback, split_object) { //retorna valor
  if(!split_object) split_object = "."
  if(typeof split_object != "string") throw new Error(`[ERROR] El signo que se usara para la clave debe ser un string`)
  if(!callback || typeof callback != "function") throw new Error('[ERROR] El segundo argumento debe ser un callback (funcion)')
  if(clave === false) {
    if(Object.keys(global_object[this.object_id]).length <= 0) return Promise.reject(ErrorDesc("PROPIEDAD NO EXISTENTE", `[find] Actualmente no hay ninguna propiedad, base de datos: ${this.database_name}`))
    for(var key in global_object[this.object_id]) {
      if(callback(global_object[this.object_id][key], key)) return Promise.resolve(global_object[this.object_id][key])
    }
    return Promise.resolve(undefined)
  }
  check_path_object(clave, split_object)

  var split_object = clave.split(split_object)
  var object_data = global_object[this.object_id]
  for(var x in split_object) {
    var key = split_object[x]
    if(typeof object_data[key] != "undefined") {
      if(x == split_object.length-1) {
        for(var key2 in object_data[key]) {
          if(callback(object_data[key][key2], key2)) return Promise.resolve(object_data[key][key2])
        }
        return Promise.resolve(undefined)
      }
      object_data = object_data[key]
      continue
    }
    return Promise.reject(ErrorDesc("PROPIEDAD NO EXISTENTE", `[find] No se encontro la propiedad ${key}, base de datos: ${this.database_name}`))
  }
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function filter(clave, callback, split_object) { //retorna un nuevo objeto con los elementos que cumplan la condicion del callback, similar al <array>.filter
  if(!split_object) split_object = "."
  if(typeof split_object != "string") throw new Error(`[ERROR] El signo que se usara para la clave debe ser un string`)
  if(!callback || typeof callback != "function") throw new Error('[ERROR] El segundo argumento debe ser un callback (funcion)')

  let filter_array = {}

  if(clave === false) {
    if(Object.keys(global_object[this.object_id]).length <= 0) return Promise.reject(ErrorDesc("PROPIEDAD NO EXISTENTE", `[filter] Actualmente no hay ninguna propiedad, base de datos: ${this.database_name}`))

    for(var key in global_object[this.object_id]) {
      if(callback(global_object[this.object_id][key], key)) filter_array[key] = global_object[this.object_id][key]
    }

    if(Object.keys(filter_array).length <= 0) return Promise.resolve(undefined)
    return Promise.resolve(filter_array)
  }
  check_path_object(clave, split_object)

  var split_object = clave.split(split_object)
  var object_data = global_object[this.object_id]
  for(var x in split_object) {
    var key = split_object[x]
    if(typeof object_data[key] != "undefined") {
      if(x == split_object.length-1) {
        for(var key2 in object_data[key]) {
          if(callback(object_data[key][key2], key2)) filter_array[key2] = object_data[key][key2]
        }

        if(Object.keys(filter_array).length <= 0) return Promise.resolve(undefined)
        return Promise.resolve(filter_array)
      }
      object_data = object_data[key]
      continue
    }
    return Promise.reject(ErrorDesc("PROPIEDAD NO EXISTENTE", `[filter] No se encontro la propiedad ${key}, base de datos: ${this.database_name}`))
  }
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


function map(clave, callback, split_object) { //retorna un array con los resultados que se especifico en el callback, similar al <array>.map
  if(!split_object) split_object = "."
  if(typeof split_object != "string") throw new Error(`[ERROR] El signo que se usara para la clave debe ser un string`)
  if(!callback || typeof callback != "function") throw new Error('[ERROR] El segundo argumento debe ser un callback (funcion)')

  if(clave === false) {
    if(Object.keys(global_object[this.object_id]).length <= 0) return Promise.reject(ErrorDesc("PROPIEDAD NO EXISTENTE", `[map] Actualmente no hay ninguna propiedad, base de datos: ${this.database_name}`))
    let map_array = new Array()

    for(var key in global_object[this.object_id]) map_array.push(callback(global_object[this.object_id][key], key))

    return Promise.resolve(map_array)
  }
  check_path_object(clave, split_object)

  var split_object = clave.split(split_object)
  var object_data = global_object[this.object_id]
  for(var x in split_object) {
    var key = split_object[x]
    if(typeof object_data[key] != "undefined") {
      if(x == split_object.length-1) {
        let map_array = new Array()

        for(var key2 in object_data[key]) map_array.push(callback(object_data[key][key2], key2))

        return Promise.resolve(map_array)
      }
      object_data = object_data[key]
      continue
    }
    return Promise.reject(ErrorDesc("PROPIEDAD NO EXISTENTE", `[map] No se encontro la propiedad ${key}, base de datos: ${this.database_name}`))
  }
}


//--------------------------------------------------------------------------------------\\
//---------------------------------------------------------------------------------------\\


crearDB.prototype.existeDB = existeDB
crearDB.prototype.establecer = establecer
crearDB.prototype.tiene = tiene
crearDB.prototype.obtener = obtener
crearDB.prototype.eliminar = eliminar
crearDB.prototype.purgeall = purgeall
crearDB.prototype.sumar = sumar
crearDB.prototype.restar = restar
crearDB.prototype.push = push
crearDB.prototype.extract = extract
crearDB.prototype.datos = datos
crearDB.prototype.ordenar = ordenar
crearDB.prototype.random = random
crearDB.prototype.convert_megadtbs = convert_megadtbs
crearDB.prototype.keys = keys
crearDB.prototype.values = values
crearDB.prototype.size = size
crearDB.prototype.find = find
crearDB.prototype.filter = filter
crearDB.prototype.map = map
